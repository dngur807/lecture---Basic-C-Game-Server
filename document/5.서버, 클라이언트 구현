# 5. 서버 , 클라이언트 구현

### 서버 클라이언트 테스트 코드 구현
지금 까지 작성한 네트워크 라이브러리를 이용하여 에코 서버를 구현해 보겠습ㄴ디ㅏ.
클라이언트가 던져누느 메시지를 다시 되돌려 주는 아주 간단한 서버이지만 지금까지 공부한 라이브러리를 활용하는데
아주 좋은 예제가 될 것이라 생각됩니다.

### 에코 서버
윈도우 콘솔 프로그램으로 에코 서버를 만드렁 보겠습니다.
비주얼스튜리오를 이용하여 CSampleServer라는 이름으로 새프로젝트를 하나 생성합니다.
프로그램의 기본 골격이 되는 코드가 생성이 되며 program 클래스의 Main 함수가 보일겁니다.
여기서 만들 서버도 윈도우 프로그램중 하나이므로 Main함수가 시작점이 됩니다.

![screensh](./resources/5_1.PNG)

첫 번째로 CPacketBufferManager를 초기화 하여 패킷을 미리 생성해 놓습니다.
파라미터로 넘기는 값은 적당한 수치를 넣어주면 되는데 여기서는 2000으로 설정하였습니다.
동시에 처리할 수 있는 패킷 클래스의 인스턴스가 최대 2000개 까지 가능하다는 뜻입니다.
사용이 끝나 반환된 패킷은 초기화 하여 재사용되기 떄문에 개수가 무한정 늘어나지는 앖습니다.
단, 너무 많이 설정할 경우 필요 이상의 메모리를 잡아먹을 수 있으니 테스트 후 적당한 수치를 넣어주는 것이 좋습니다.

다음 으로 접속할 유저들을 관리할 리스트를 생성합니다.
그 아래줄 부터는 네트워크 초기화를 위한 코드 입니다.
CNetworkService 객체를 생성한 뒤 클라이언트가 접속할 때 마다 호출될 콜백 매소드를 설정해 줍니다.
클라이언트 한명이 접속 성공할 때 마다 지정된 콜백 매소드가 호출되게 됩니다.

그리고 CNetworkService 초기화를 수행한 뒤, listen매소드를 호출하여 클라이언트의 접속을 기다리는 상태로 만들어 줍니다.
listen매소드의 파라미터는 host ip , port , backlog 값으로 구성되어 있습니다.
host, ip 는 서버 ip주소를 의미하며 , 0.0.0.0으로 넣어주면 모든 데이터를 다 받아들입니다. 
서버 에서 여러개의 IP주소를 설정하여 사용할 경우도 있는데 이 설정과 관계없이 어떤 IP주소라도 해당 포트로 들어오는 데이터는
모두 다 수신하겠다는 뜻입니다.

포트는 서버 어플리케이션에서 사용할 포트 번호입니다. 이미 알려진 포트 (21, 80)을 제외하고 사용해야 다른 어플리케이션과 충돌 하지 않습니다.
마지막으로 backlog값을 넣어줍니다. 이 값은 accept처리 도중 대기 시킬 연결 개수를 의미합니다.
accept 처리가 아직 끝나지 않은 상태에서 또 다른 연결 요청이 들어온다면 backlog로 설정된 값 만큼 대기 큐에 대기 시켜 놓습니다.
accept처리가 끝나면 대기 큐에서 하나씩 빼내서 다음 연결 처리를 진행시켜 주게 됩니다.
이 값을 무턱대고 크게 설정하면 리소스를 잡아먹을 수도 있으니 테스트 후 적당한 값을 넣는것이 좋습니다.

네트워크 초기화가 완료되면 프로그램이 중지되지 않도록 무한 루프를 돌려줍니다.
메인 스레드가 블러킹 되면 안되기 때문에 Sleep을 통해서 적당히 쉬어주는 코드도 넣어줬습니다.

보시다 시피 Main 함수의 내용은 특별할것이 없습니다.
나머지 코드들도 간단하기 그지 없습니다.

![screensh](./resources/5_2.PNG)

CNetworkService 의 콜백 매소드로 설정해준 on_session_created매소드 입니다,. 클라이언트의 접속이 성공할 때 마다
네트워크 라이브러리에서 호출해 주게 되죠. CGameUser 클래스의 인스턴스를 하나 생성해 주는데 이 클래스는 에코 서버에서 사용할 간단한 유저 객체를 나타냅니다.
그리고 현재 접속하고 있는 유저를 관리하기 위해서 앞서 만든 userlist관리를 위한 코드만 들어가 있습니다.
에코 서버는 클라이언트가 보내온 메시지를 그대로 돌려주는 일만 수행하기 때문에 유저와 관련된 내용은 복잡할 게 없습니다.


단 여기서 주의할 점은 userlist에 변화가 생길 때 lock으로 묶어줘야 한다는 것입니다.
userlist는 여러 스레드에서 사용하는 공유 자원이기 때문에 반드시 lock처리를 해줘야 리스트가 깨지지 않습니다.
물론 아주 운이 좋다면(실제로는 나쁜경우지만) lock 처리를 해제하여도 잘 돌아가는 경우가 있을겁니다.
하지만 멀티 스레드 환경에서는 한두번 잘 돌아간다고 계속 잘 되리라는 보장은 절대 없습니다.
코드의 흐름을 잘 파악하여 lock이 필요한 부분은 데이터가 깨지지 않도록 보호 조치를 해주는 것이 반드시 필요합니다.


### 유저 객체
Main함수 구현 부분에서 CGameUser리스트를 생성하여 관리하는 코드를 보셨을 겁니다.
클라이언트와 1:1관계로 매칭되는 유저 객체라고 생각하시면 됩니다. 동시 접속자가 1000명이면 CGameUser인스턴스도 1000개 생성
되는 것입니다. CGameUser클래스는 길이가 얼마 되지 않으니 전체 코드를 살펴보도록 하겠습니다.


![screensh](./resources/5_3.PNG)

생성자에서는 메시지 송, 수신시 사용할 CUserToken 객체를 멤버변수로 보관해 놓습니다.
그리고 CUserToken객체에 IPeer인터페이스를 구현한 자기 자신의 인스턴스를 넘겨줍니다. 네트워크 모듈에서
클라이언트의 접속 요청, 종료등의 처리시 해당 인터페이스를 통해서 CGameUser의 매소드를 호출해주기 위함입니다.
네트워크 모듈에서 이런 저런 처리를 한 뒤 어플리케이션으로 그 사실을 통보해줄 때 필요한 부분입니다.

Ipeer.on_message 매소드는 클라이언트로 메시지가 수신되었을 떄 호출됩니다.
파라미터로 byte배열이 넘어오기 떄문에 이것을 패킷 객체로 변환하여 사용하는 것이 좋습니다.
프로토콜 아이디를 읽어온 뒤 해당 아이디에 맞는 로직으로 분기시켜 줍니다.


![screensh](./resources/5_4.PNG)

에코 서버는 클라이언트가 전송한 내용을 그대로 돌려주는 역할 이기 떄문에 
pop_string()으로 꺼내온 데이터를 그대로 다시 push 하여 응답해 줍니다.
이 때 프로토콜은 CHAT_MSG_REQ에 대응하는 CHAT_MSG_ACK를 사용하여 클라이언트에서 인지할 수 있도록 처리해 줍니다.

그 다음으로 클라이언트와의 연결이 끊겼을 때 호출되는 on_removed와 데이터 전송시 사용할 send 매소드가 있습니다.
on_removed는  모듈에서 자동으로 호출되는 매소드 이므로 우리는 통보 사실을 전달받아 어플리케이션의 로직 처리만 수행해주면 됩니다.
send매소드는 생성자에서 보관해 놓은 CUserToken객체의 send매소드를 호출하여 데이터 전송을 요청합니다.


코드를 보시다가 CUserToken클래스와 CGameUser클래스 두가지가 왜 구분되어 있는지 궁금해 하실수도 있을겁니다. 
그 이유는 각각의 역할 분담을 명확히 하기 위해서 입니다. CUserToken은 네트워크 모듈에 속해 있는 클래스 이며 소켓API와
좀 더 가까운 컨셉으로 설계된 클래스입니다. 반면 CGameUser는 네트워크 모듈 보다는 어플리케이션 로직과 가까운 클래스 이며
구현하려는 서버마다 각기 다른 내용으로 채워져 있을 수 있습니다.
이 말은 그만큼 변경사항이 많이 생길 수 있다는 말이기도 합니다. 따라서 데이터 송, 수신등의 처리에 필요한
CUserToken클래스와는 별도로 구성하는 것이 바람직 하겠죠.

Ipeer.disconnect() 매소드는 서버에서 클라이언트의 연결을 강제로 끊을 떄 사용합니다.
매소드 내용도 아주 간단합니다.

void IPeer.process_user_operation(CPacket msg) 매소드는 에코 서버에서는 사용되지 않는 매소드 입니다.
이 매소드는 실전 예제 강좌에서 활용하도록 하겠습니다. 일단 비워둡시다.

여기 까지 에코 서버의 구현이 모두 완료되었습니다.
네트워크 처리 부분은 모두 라이크러리로 구현되어 있기 때문에 어플리케이션에서는 별로 복잡한 내용은 없습니다.
다음으로는 클라이언트 구현을 보겠습니다.

### 클라이언트
클라이언트 역시 간단합니다. 서버에 접속한 뒤 키보드 입력을 받아 전송하고 수신된 데이터를 화면에 출력해주면 끝입니다.
CSampleClient라는 이름으로 새로운 프로젝트를 생성합니다.
먼저 Main함수를 살펴보죠.
